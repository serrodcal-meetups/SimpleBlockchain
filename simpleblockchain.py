# -*- coding: utf-8 -*-
"""SimpleBlockchain.ipynb
Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/serrodcal/SimpleBlockchain/blob/master/SimpleBlockchain.ipynb
"""

import uuid
import time
import json
from hashlib import sha256
from Crypto import Random
from Crypto.PublicKey import RSA
from Crypto.Cipher import PKCS1_OAEP
from Crypto.Signature import PKCS1_v1_5
from Crypto.Hash import SHA512, SHA384, SHA256, SHA, MD5

def generate_key(bits=2048):
    random_generator = Random.new().read
    key = RSA.generate(bits, random_generator)
    sk, pk = key, key.publickey()
    return sk, pk

sk, pk = generate_key()

print(sk.exportKey())

print(pk.exportKey())

def encrypt(message, pk):
    #RSA encryption protocol according to PKCS#1 OAEP
    cipher = PKCS1_OAEP.new(pk)
    return cipher.encrypt(message)

def decrypt(ciphertext, sk):
    #RSA encryption protocol according to PKCS#1 OAEP
    cipher = PKCS1_OAEP.new(sk)
    return cipher.decrypt(ciphertext)

def sign(message, sk, hashAlg="SHA-256"):
    global hash
    hash = hashAlg
    signer = PKCS1_v1_5.new(sk)
    if (hash == "SHA-512"):
        digest = SHA512.new()
    elif (hash == "SHA-384"):
        digest = SHA384.new()
    elif (hash == "SHA-256"):
        digest = SHA256.new()
    elif (hash == "SHA-1"):
        digest = SHA.new()
    else:
        digest = MD5.new()
    digest.update(message)
    return signer.sign(digest)

def verify(message, signature, pk):
    signer = PKCS1_v1_5.new(pk)
    if (hash == "SHA-512"):
        digest = SHA512.new()
    elif (hash == "SHA-384"):
        digest = SHA384.new()
    elif (hash == "SHA-256"):
        digest = SHA256.new()
    elif (hash == "SHA-1"):
        digest = SHA.new()
    else:
        digest = MD5.new()
    digest.update(message)
    return signer.verify(digest, signature)

message = 'My name is Alice!'
encoded_message = message.encode()
encrypted_message = encrypt(encoded_message, pk)
print(encrypted_message)

decrypted_encoded_message = decrypt(encrypted_message, sk)
decoded_message = decrypted_encoded_message.decode()
print(decoded_message)

signed_message = sign(encoded_message, sk)
print(signed_message)

verified = verify(encoded_message, signed_message, pk)
print(verified)

keystore = {}
#Alice
a_sk, a_pk = generate_key()
keystore['alice'] = (a_sk, a_pk)
#Bob
b_sk, b_pk = generate_key()
keystore['bob'] = (b_sk, b_pk)
#Charlie
c_sk, c_pk = generate_key()
keystore['charlie'] = (c_sk, c_pk)

class Transaction:
    def __init__(self, id, author, content, timestamp, signature, public_key):
        self.id = id
        self.author = author
        self.content = content
        self.timestamp = timestamp
        self.signature = signature
        self.public_key = public_key

    def __str__(self):
        attributes = {}
        attributes['id'] = self.id
        attributes['author'] = self.author
        attributes['content'] = self.content
        attributes['timestamp'] = self.timestamp
        attributes['signature'] = str(self.signature)
        attributes['public_key'] = self.public_key.exportKey().decode()
        return json.dumps(attributes)

    def verify_transaction(self):
        encoded_message = ('-'.join([self.id, self.author, self.content, self.timestamp])).encode()
        return verify(encoded_message, self.signature, self.public_key)

transaction1_info = ['1','alice','alice_content1',str(time.time())]
transaction1_message = "-".join(transaction1_info)
transaction1_encode_message = transaction1_message.encode()
transaction1_signature = sign(transaction1_encode_message, sk)
transaction1 = Transaction(transaction1_info[0], transaction1_info[1], transaction1_info[2], transaction1_info[3], transaction1_signature, pk)
print(transaction1)
print(transaction1.verify_transaction())

class Block:
    def __init__(self, index, transactions, timestamp, previous_hash):
        self.index = index
        self.transactions = transactions
        self.timestamp = timestamp
        self.previous_hash = previous_hash
        self.nonce = 0

    def compute_hash(self):
        attributes = self.__dict__.copy()
        transaction_str = [str(transaction) for transaction in self.transactions]
        attributes['transactions'] = transaction_str
        block_string = json.dumps(attributes)
        return sha256(block_string.encode()).hexdigest()

block1 = Block(1, [transaction1], time.time(), '0')
hash_block1 = block1.compute_hash()
print(hash_block1)

class Blockchain:

    def __init__(self, difficulty=2, block_len=3):
        self.difficulty = difficulty
        self.block_len = block_len
        self.unconfirmed_transactions = []
        self.chain = []
        self.create_genesis_block()

    def create_genesis_block(self):
        genesis_block = Block(0, [], time.time(), "0")
        self.chain.append(genesis_block)

    def add_transaction(self, transaction):
            self.unconfirmed_transactions.append(transaction)

    def has_unconfirmed_transactions(self):
        if self.unconfirmed_transactions:
            return True
        return False

    def number_of_blocks(self):
        return len(self.chain)

    def last_block(self):
        return self.chain[-1]

    def proof_of_work(self, block):
        computed_hash = block.compute_hash()
        while not computed_hash.startswith('0' * self.difficulty):
            block.nonce += 1
            computed_hash = block.compute_hash()
        return computed_hash, block

    def check_proof(self, block, block_hash):
        return (block_hash.startswith('0' * self.difficulty) and
                block_hash == block.compute_hash())

    def add_block(self, block, proof):
        previous_hash = self.last_block().compute_hash()

        if previous_hash != block.previous_hash:
            return False

        if not self.check_proof(block, proof):
            return False

        self.chain.append(block)
        return True

    def mine(self):

        if len(self.unconfirmed_transactions) < self.block_len:
            return False

        while len(self.unconfirmed_transactions) > self.block_len:
            previous_block = self.last_block()
            current_unconfirmed_transaction = [self.unconfirmed_transactions.pop(0) for _ in range(self.block_len)]
            new_block = Block(index=previous_block.index + 1,
                          transactions=current_unconfirmed_transaction,
                          timestamp=time.time(),
                          previous_hash=previous_block.compute_hash())
            proof, updated_block = self.proof_of_work(new_block)
            self.add_block(updated_block, proof)

        return self.last_block().index

def create_transaction(info, sk, pk):
    message = "-".join(info)
    encoded_message = message.encode()
    signature = sign(encoded_message, sk)
    return Transaction(info[0], info[1], info[2], info[3], signature, pk)

transactions = [[uuid.uuid4().hex,'alice','alice_content1',str(time.time())],
[uuid.uuid4().hex,'bob','bob_content1',str(time.time())],
[uuid.uuid4().hex,'charlie','charlie_content1',str(time.time())],
[uuid.uuid4().hex,'alice','alice_content2',str(time.time())],
[uuid.uuid4().hex,'bob','bob_content2',str(time.time())],
[uuid.uuid4().hex,'charlie','charlie_content2',str(time.time())],
[uuid.uuid4().hex,'alice','alice_content3',str(time.time())],
[uuid.uuid4().hex,'bob','bob_content3',str(time.time())],
[uuid.uuid4().hex,'charlie','charlie_content3',str(time.time())],
[uuid.uuid4().hex,'alice','alice_content4',str(time.time())],
[uuid.uuid4().hex,'bob','bob_content4',str(time.time())],
[uuid.uuid4().hex,'charlie','charlie_content4',str(time.time())],
[uuid.uuid4().hex,'alice','alice_content5',str(time.time())]]

blockchain = Blockchain()

for transaction in transactions:
    transaction_obj = create_transaction(transaction, keystore[transaction[1]][0], keystore[transaction[1]][1])
    blockchain.add_transaction(transaction_obj)

last_index = blockchain.mine()

print(last_index)

print(blockchain.has_unconfirmed_transactions())
print(len(blockchain.unconfirmed_transactions))
last_transaction = blockchain.unconfirmed_transactions[0]
print(last_transaction)

info = [last_transaction.id, last_transaction.author, last_transaction.content, last_transaction.timestamp]
message = "-".join(info)
signature = sign(message.encode(), keystore['alice'][0])
print(last_transaction.public_key == keystore['alice'][1])
print(last_transaction.signature == signature)
print(last_transaction.verify_transaction())
print(verify(message.encode(), signature, keystore['alice'][1]))

last_block = blockchain.last_block()
print(last_block.nonce)
print(last_block.compute_hash())
